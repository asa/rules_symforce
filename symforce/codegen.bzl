load("@symforce_requirements//:requirements.bzl", "requirement")

def _impl(ctx):
    arguments = [
        "compile",
        "--basename",
        ctx.attr.basename,
        "--input_path",
        ctx.file.src.path,
        "--function_name",
        ctx.attr.function_name,# name of python function to codegen from
        "--output_function_path",
        ctx.outputs.output_function_path.path,
    ]
    all_outputs = [ctx.outputs.output_function_path]

    if ctx.attr.function_is_generator:
        arguments.append("--function_is_generator")

    if ctx.attr.should_output_factor:
        arguments.extend(["--output_factor_path", ctx.outputs.output_factor_path.path])
        all_outputs.append(ctx.outputs.output_factor_path)

    for arg in ctx.attr.arguments:
        arguments.extend(["--arguments", arg])

    for name in ctx.attr.output_names:
        arguments.extend(["--output_names", name])

    ctx.actions.run(
        inputs = [ctx.file.src],
        outputs = all_outputs,
        arguments = arguments,
        mnemonic = "SymforceCompile",
        progress_message = "Compiling symforce...",
        executable = ctx.executable.compiler,
    )

    return struct(
        proto = struct(srcs = [ctx.file.src]),
    )

_codegen = rule(
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "basename": attr.string(
            mandatory = True,
        ),
        "function_name": attr.string(
            mandatory = True,
        ),
        "function_is_generator": attr.bool(),
        "arguments": attr.string_list(
            mandatory = True,
        ),
        "output_names": attr.string_list(
            mandatory = True,
        ),
        "compiler": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("@rules_symforce//symforce:compiler"),
        ),
        "should_output_factor": attr.bool(),
        "out_residual": attr.output(mandatory = True),
        "outpu_factor": attr.output(mandatory = False),
    },
    #output_to_genfiles = True,
    implementation = _impl,
)

_symforce = rule(
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "basename": attr.string(
            mandatory = True,
        ),
        "function_name": attr.string(
            mandatory = True,
        ),
        "function_is_generator": attr.bool(),
        "arguments": attr.string_list(
            mandatory = True,
        ),
        "output_names": attr.string_list(
            mandatory = True,
        ),
        "compiler": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("@rules_symforce//symforce:compiler"),
        ),
        "should_output_factor": attr.bool(),
        "output_function_path": attr.output(mandatory = True),
        "output_factor_path": attr.output(mandatory = False),
    },
    #output_to_genfiles = True,
    implementation = _impl,
)

#the function can be specified via function or function generator
def cc_symforce_factor(name, 
                        src, 
                        function = None, 
                        function_generator = None, 
                        arguments = [], 
                        output_names = [], 
                        deps = []):
        
        if (function and function_generator):
            fail("only a function or function_generator must be specified")

        basename = name
        output_factor_path = basename + ".h"
        output_function_path = basename + "_residual.h"

        _symforce(
            name = name + "_factor_gen",
            basename = name,
            src = src,
            function_name = function_generator or function,
            function_is_generator = True if function_generator != None else False,
            arguments = arguments,
            #input_names = input_names, generated by the function
            output_names = output_names,
            should_output_factor = True,
            output_function_path = output_function_path,
            output_factor_path = output_factor_path,
        )

        native.py_library(
                name = name + "_pylib",
                srcs = [
                        src,
                ],
                deps = [
                        requirement("symforce-sym"),
                        requirement("symforce"),  # this one is from pip
                        requirement("sympy"),
                        ],
        )

        native.cc_library(
            name = name,
            hdrs = [output_function_path, output_factor_path],
            deps = ["@eigen", "@symforce"] + deps,
            visibility = ["//visibility:public"],
        )

# generalized codegen for python -> c++
def cc_symforce_library(name, 
                        src, 
                        function = None, 
                        function_generator = None, 
                        arguments = [], 
                        output_names = [], 
                        deps = []):
        if (function and function_generator):
            fail("only a function or function_generator must be specified")

        basename = name
        output_function_path = basename + ".h"

        _symforce(
            name = name + "_gen",
            basename = basename,
            src = src,
            function_name = function_generator or function,
            function_is_generator = True if function_generator != None else False,
            arguments = arguments,
            output_names = output_names,
            output_function_path = output_function_path,
            should_output_factor = False,
        )
        native.py_library(
                name = name + "_pylib",
                srcs = [
                        src,
                ],
                deps = [
                        requirement("symforce-sym"),
                        requirement("symforce"),  # this one is from pip
                        requirement("sympy"),
                        ],
        )
        native.cc_library(
            name = name,
            hdrs = [output_function_path],
            deps = ["@eigen", "@symforce"] + deps,
            visibility = ["//visibility:public"],
        )
