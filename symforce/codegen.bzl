def _impl(ctx):
    arguments = [
        "compile",
        "--input_path",
        ctx.file.src.path,
        "--function",
        ctx.attr.function,# name of python function to codegen from
        "--output_function_path",
        ctx.outputs.output_function_path.path,
    ]
    all_outputs = [ctx.outputs.output_function_path]

    if ctx.attr.function_is_generator:
        arguments.append("--function_is_generator")

    if ctx.attr.should_output_factor:
        arguments.extend(["--output_factor_path", ctx.outputs.output_factor_path.path])
        all_outputs.append(ctx.outputs.output_factor_path)

    for arg in ctx.attr.arguments:
        arguments.extend(["--arguments", arg])

    for name in ctx.attr.output_names:
        arguments.extend(["--output_names", name])

    ctx.actions.run(
        inputs = [ctx.file.src],
        outputs = all_outputs,
        arguments = arguments,
        mnemonic = "SymforceCompile",
        progress_message = "Compiling symforce...",
        executable = ctx.executable.compiler,
    )

    return struct(
        proto = struct(srcs = [ctx.file.src]),
    )

_codegen = rule(
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "function": attr.string(
            mandatory = True,
        ),
        "function_is_generator": attr.bool(),
        "arguments": attr.string_list(
            mandatory = True,
        ),
        "output_names": attr.string_list(
            mandatory = True,
        ),
        "compiler": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("@rules_symforce//symforce:compiler"),
        ),
        "should_output_factor": attr.bool(),
        "out_residual": attr.output(mandatory = True),
        "outpu_factor": attr.output(mandatory = False),
    },
    #output_to_genfiles = True,
    implementation = _impl,
)

_symforce = rule(
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "function": attr.string(
            mandatory = True,
        ),
        "function_is_generator": attr.bool(),
        "arguments": attr.string_list(
            mandatory = True,
        ),
        "output_names": attr.string_list(
            mandatory = True,
        ),
        "compiler": attr.label(
            executable = True,
            cfg = "exec",
            default = Label("@rules_symforce//symforce:compiler"),
        ),
        "should_output_factor": attr.bool(),
        "output_function_path": attr.output(mandatory = True),
        "output_factor_path": attr.output(mandatory = False),
    },
    #output_to_genfiles = True,
    implementation = _impl,
)

def cc_symforce_factor(name, 
                        src, 
                        function, 
                        arguments = [], 
                        function_is_generator = False, 
                        output_names = [], 
                        deps = []):
        output_function_path = name + "_residual.h"
        output_factor_path = name + "_factor.h"
        _symforce(
            name = name + "_factor_gen",
            src = src,
            function = function,
            function_is_generator = function_is_generator,
            arguments = arguments,
            #input_names = input_names, generated by the function
            output_names = output_names,
            should_output_factor = True,
            output_function_path = output_function_path,
            output_factor_path = output_factor_path,
        )

        native.cc_library(
            name = name,
            hdrs = [output_function_path, output_factor_path],
            deps = ["@eigen", "@symforce"] + deps,
            visibility = ["//visibility:public"],
        )

# generalized codegen for python -> c++
def cc_symforce_library(name, 
                        src, 
                        function, 
                        arguments = [], 
                        function_is_generator = False, 
                        output_names = [], 
                        deps = []):

        output_function_path = name + ".h"
        # for imu factor for instance
        _symforce(
            name = name + "_gen",
            src = src,
            function = function,
            function_is_generator = function_is_generator,
            arguments = arguments,
            output_names = output_names,
            output_function_path = output_function_path,
            should_output_factor = False,
        )

        native.cc_library(
            name = name,
            hdrs = [output_function_path],
            deps = ["@eigen", "@symforce"] + deps,
            visibility = ["//visibility:public"],
        )
